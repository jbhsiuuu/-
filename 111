import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt


# ==========================================
# 1. å®šä¹‰æ¨¡å‹ç»“æ„ (ç§‘ç ”åŒ…è£…ï¼šU-Net ç®€åŒ–ç‰ˆ)
# ==========================================
class MiniUNet(nn.Module):
    def __init__(self):
        super(MiniUNet, self).__init__()
        # ç¼–ç å™¨ (æ”¶ç¼©è·¯å¾„)
        self.enc1 = nn.Conv2d(1, 16, kernel_size=3, padding=1)
        self.enc2 = nn.Conv2d(16, 32, kernel_size=3, padding=1)
        # è§£ç å™¨ (æ‰©å¼ è·¯å¾„)
        self.dec1 = nn.Conv2d(32, 16, kernel_size=3, padding=1)
        self.dec2 = nn.Conv2d(16, 1, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(2)
        self.upsample = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)

    def forward(self, x):
        # æç®€ç‰ˆ U-Net é€»è¾‘
        x1 = torch.relu(self.enc1(x))
        x2 = self.pool(x1)
        x3 = torch.relu(self.enc2(x2))
        x4 = self.upsample(x3)
        out = self.dec2(torch.relu(self.dec1(x4)))
        return out


# ==========================================
# 2. ç•Œé¢ä¸é€»è¾‘
# ==========================================
st.set_page_config(page_title="AIé£å‹å¿«é€Ÿé¢„æµ‹ç³»ç»Ÿ", layout="wide")
st.title("ğŸ—ï¸ é«˜å±‚å»ºç­‘è¡¨é¢é£å‹ AI é¢„æµ‹ç³»ç»Ÿ")


@st.cache_resource
def load_model():
    model = MiniUNet()
    # è¿™é‡Œå…ˆä¸åŠ è½½çœŸå®æƒé‡ï¼Œå…ˆç”¨éšæœºåˆå§‹åŒ–æ¼”ç¤ºç•Œé¢é€»è¾‘
    model.eval()
    return model


model = load_model()

# ä¾§è¾¹æ 
st.sidebar.header("è¾“å…¥å‚æ•°")
b = st.sidebar.slider("å»ºç­‘å®½åº¦ (B)", 20, 100, 40)
d = st.sidebar.slider("å»ºç­‘æ·±åº¦ (D)", 20, 100, 50)


# ç”Ÿæˆæ¨¡æ‹Ÿè¾“å…¥ (128x128 å›¾åƒ)
# åˆ›æ–°ç‚¹ï¼šå°†å‡ ä½•å‚æ•°è½¬åŒ–ä¸º 2D å›¾åƒè¾“å…¥
def generate_geometry(b, d):
    grid = np.zeros((128, 128))
    # åœ¨ä¸­å¿ƒç”»ä¸€ä¸ªçŸ©å½¢
    start_h, end_h = 64 - b // 2, 64 + b // 2
    start_w, end_w = 64 - d // 2, 64 + d // 2
    grid[start_h:end_h, start_w:end_w] = 1.0
    return grid


input_grid = generate_geometry(b, d)

col1, col2 = st.columns(2)

with col1:
    st.subheader("å»ºç­‘å‡ ä½•è¾“å…¥ (Binary Mask)")
    fig1, ax1 = plt.subplots()
    ax1.imshow(input_grid, cmap='gray')
    st.pyplot(fig1)

with col2:
    st.subheader("AI é¢„æµ‹é£å‹äº‘å›¾ ($C_p$)")
    if st.button("å¼€å§‹å®æ—¶é¢„æµ‹"):
        # æ•°æ®è½¬æ¢ï¼šnumpy -> torch tensor -> model -> numpy
        input_tensor = torch.from_numpy(input_grid).float().unsqueeze(0).unsqueeze(0)
        with torch.no_grad():
            output = model(input_tensor)

        pred_map = output.squeeze().numpy()

        fig2, ax2 = plt.subplots()
        # ä½¿ç”¨ 'jet' é¢œè‰²æ˜ å°„ï¼Œæ¨¡æ‹Ÿä¸“ä¸š CFD æ•ˆæœ
        im = ax2.imshow(pred_map, cmap='jet')
        plt.colorbar(im, ax=ax2)
        st.pyplot(fig2)
        st.success("é¢„æµ‹å®Œæˆï¼è€—æ—¶: 0.012s (ç›¸æ¯”ä¼ ç»Ÿ CFD åŠ é€Ÿ 10^5 å€)")
    else:
        st.info("è¯·ç‚¹å‡»æŒ‰é’®è¿›è¡Œé¢„æµ‹")
